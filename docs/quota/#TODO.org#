## -*- mode: org -*-

* functionse
** table
|                          |     |    |     |    |    | On | d | d |
|                          |     |    |     | qd | dq | Of | a | r |
| func name                | lst | st | ptr | lk | io |    | t | t |
|--------------------------+-----+----+-----+----+----+----+---+---|
| wait_on_dquot            |     |    |     | +- |    |    |   |   |
| dquot_mark_dquot_dirty   | ad  |    |     |    |    |    |   |   |
| clear_dquot_dirty        | Grd |    |     |    |    |    |   |   |
| dquot_acquire            |     |    |     | 1  |  2 |    |   |   |
| dquot_commit  cl drt     | 2rd |    |     |    |  1 |    |   |   |
| dquot_release            |     |    |     | 1  |  2 |    |   |   |
| invalidate_dquots INLK   |     |    |     |    |    |    |   |   |
| dquot_scan_active ocfs2  | 2ti |    |     |    |    |  1 |   |   |
| vfs_quota_sync ->wr_dq   | 2td |    |     |    |    |  1 |   |   |
| shrink_dqcache_memory    | dif |    |     |    |    |    |   |   |
| dqput lts_l: dq_count    | 1   |    |     |    |    |    |   |   |
| dqget lst_l: dqhash      | 1   |  2 |     |    |    |    |   |   |
| dquot_initialize ->dqget |     |    | ?WR |    |    |    |   |   |
| add_dquot_ref / INLK     |     |    |     |    |    |  g |   |   |
| remove_inode_dquot_ref   | 1aF |    | gWR |    |    |    |   |   |
| remove_dquot_ref /  INLK |     |    |     |    |    |    |   |   |
| drop_dquot_ref /         |     |    | WR  |    |    |    |   |   |
| dquot_drop   ->dqput     |     |    | WR  |    |    |    |   |   |
| dquot_transfer ->dqget   |     |    | WR2 |    |    |    | 1 | 1 |
| dquot_commit_info        |     |    |     |    |  1 |    |   |   |
| vfs_quota_disable        |     |  2 |     |    |    |  1 |   |   |
| vfs_load_quota_inode     |     |  3 | WR2 |    |  3 |  1 |   |   |
|                          |     |    |     |    |    |    |   |   |
| __dquot_alloc_space [as] |     |    |     |    |    |    | 1 |   |
| dquot_alloc_space  ->as  |     |    | rd  |    |    |    |   | 1 |
| dquot_reserve_space ->as |     |    | rd  |    |    |    |   |   |
| dquot_alloc_inode        |     |    | rd  |    |    |    | 1 | 1 |
| dquot_claim_space        |     |    | rd  |    |    |    | 1 | 1 |
| dquot_release_rsrv_spc   |     |    | rd  |    |    |    | 1 |   |
| dquot_free_space         |     |    | rd  |    |    |    | 1 | 1 |
| dquot_free_inode         |     |    | rd  |    |    |    | 1 | 1 |
*dat*: dq_data_lock
*drt*: mark_quota_dirty() is called form this function.
i: inuse_list
d: dirty_list
f: free_list
F: tofree_head (dq_free) in remove_inode_dquot_ref()
g: guarded by this lock, caller must hold it.
INLK : inode_lock
in dqptr:  WR = down_write, rd = down_read
---------------------------------------------------------------------
#+BEGIN_EXAMPLE c
sb->dq_op->write_dquot     => dquot_commit
dquot_commit(dquot)
  dqopt->opt[cnt]->commit_dq_blk(dquot) quota_format_ops
  if(info_dirty(info)) {
    dqopt->ops->write_file_info()
#+END_EXAMPLE
*** functions
dquot_acquire: set: DQ_READ_B,DQ_ACTIVE_B
dquot_release: clr: DQ_ACTIVE_B
**** dqput: 
  again:
     spin_lock(dq_list_lock)
     if (dquot->dq_count > 1)
         atoim_dec(dquot->dq_count)
         if (!sb_has_active)  wake_up /* quotaoff */
         return;
     else /* final dqput */
     if (DQ_ACTIVE_B) && dquot_dirty
        unlock(dq_list_lock); ->write_dquot() lock(dq_list_lock);
     /* list_lock was unlocked so dq_count may be changed, goto again */
      goto again;
      if (DQ_ACTIVE_B)
         unlock(dq_list_lock)  release_dquot(dquot);lock(dq_list_lock)
      goto again;
      atomic_dec(dquot->dq_count)
      put_dquot_last(dquot);
      spin_unlock(dq_list_lock)
ON/off function
vfs_quota_on_remount
vfs_quota_on_path
** Thoughts
*** dquot_initialize
    This functions takes dqptr_sem for write, but it just add dquot to inode.
    *Seems* what it can not race with charge_functions (who held it for read)
    i_dquot NULL => good_val even with down_read(dqptr_sem)
    i_dquot good_val => NULL only with down_write(dqptr_sem)
*** dquot_on
#+BEGIN_EXAMPLE bash
    Currently we have no problem with space reservation for new quotas.
    simple testcase:
    quotactl --type 0 --off --device=/dev/sdb5 --path /mnt
    quotactl --type 1 --on --device=/dev/sdb5 --path /mnt
    dd if=/dev/zero of=/mnt/FILE bs=1M count=32
    quotactl --type 0 --on --device=/dev/sdb5 --path /mnt
    touch /mnt/FILE  # -> vfs_dq_init (type == 0)
    sync # -> dquot_claim_space() -> reserve = 0 ==> WARN_ON:964
    What we have to do? sync inode before attach?
#+END_EXAMPLE
*** visiable quota changes
    quota_write/read performed via extXXX_bread() which is call 
    ext4_getblk(handle, inode, block, create, err);
    ->ext4_get_blocks(handle, inode, block, 1, &dummy, flags);
    ->sb_getblk(inode->i_sb, dummy.b_blocknr);
    So, read from blkdev pagecache, thats why it is not visiable in
    quota's file page cache after write :).
* TOP ISSUES
** TODO quota_write
    Currently all modification operations in case of journalled quota
    result in quota_write. Which result in write with i_mutex :)
    This is real show stopper because all modification operation
    will be sequential.
    Think about concurent writes
*** Possible solutions.
    Some how we have to avoid i_mutex 
    - Introduce rw semaphore for quota file access
      * If quota already exist in file an i_size will not changed then 
	require sem for read.
      * Every other cases requires write sem.

    - statically allocate enough space for quota file and access without
      i_mutex

** TODO smart_make_dirty
   In journal mode all modification operations result in
   explicit quota write under qio_mutex. This fatally destroying
   performance. In fact this is not what we whant. we just want
   what data we change passed to the same transaction.
   this is possible because only one transaction may be open at
   a time. And quota functions always called with open transactions
*** SMART MAKE DIRTY technique
  We allow only one waiter at the time. This is the only sane solution.
  
#+BEGIN_EXAMPLE c
/* 
 * Jurnalled quota assumes that data and quota io must belongs to the
 * same transaction.
 */
static int mark_dirty_journalled(struct inode * inode, int nr, int wait)
{
	struct dquot tmp;
	int ret = 0;
	spin_lock(&data_lock);
	__dquot.dq_dqb.dqb_curspace += nr;
	spin_unlock(&data_lock);

	/* the core algorithm */
	if (!test_and_set_bit(DQ_IO_B, &dquot->dq_flags))
		/* Ok there is a other waiter of the mutex */
		return 0;

	mutex_lock(&inode->i_mutex);
	/*
	 * After mutex is locked by us, let every body know's what
	 * new portion of data was scheduled for write.
	 */
        clear_bit(DQ_IO_B, &dquot->dq_flags);	 

	spin_lock(&data_lock);
	memcpy(&tmp, &__dquot, sizeof(__dquot));
	spin_unlock(&data_lock);

	ret = commit_quot(inode, &tmp);

	mutex_unlock(&inode->i_mutex);
	return ret;
}
#+END_EXAMPLE
** TODO rewrite vfs_dq_init [1/2]
   - [X] dqptr\_sem-improvements.patch :: transfer ptr_sem from write to read
   - [ ] check :: check i\_dquot before calling dqget() this cover most of cases.  

* Changes
** dq_data_lock
   protect dquot->dq_dqblk and some bits in dquot->dq_flags  \\
   dq_dqblk is mostly for writes, so just protect it with per dquot spin_lock
** dqget/dqput
*** rename dqget() to dquot_lookup().
    Because it is responsible for lookup, not get.
    - dquot_lookup() :: should call dqget_sb() for each new dquot,
			and call dqput_sb on dquot_release()
*** dquot_release()
    should call dqput_sb on release
*** dqput_sb()
    should call wakeup for the last ref.
*** quota disable path / remount/ disable  and so on
    should wait for for last dqput_sb() if any.
*** add dqget(struct dquot)
    { atomic_inc(&dquot.dq_count); }
*** dqput just call
    { atomic_dec_and_lock(&dquot.dq_count, )}
*** add __dquot_lookup_nolock
    Which just search quota in the hash tree and return dq
* Charts
open-close 1000000 on one fs but in different directories

| num task | ext4 w/o patch | ext4 + dquot_inittialize fix |
|          | 3197908  312   | 3143428  318                 |
|          | 3157374  316   | 3169983  315                 |
|          | 3173014  315   | 3168818  315                 |
|          |                |                              |
|          | 4450697  224   | 4564706  219                 |
|          | 4605507  217   | 4596803  217                 |
|          | 4660029  214   |                              |
|          |                |                              |
|          | 7341495  136   |                              |
|          | 7711750  129   |                              |
|          | 8070471  123   |                              |
|          |                |                              |
|          | 10800260  92   |                              |
|          | 11699372  85   |                              |
|          | 10882656  91   |                              |
|          |                |                              |



